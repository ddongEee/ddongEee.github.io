<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Crayon&#39;s Blog</title>
    <link>http://ddongeee.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 04 Jan 2022 06:02:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Jambda = Java + Lambda</title>
      <link>http://ddongeee.github.io/2022/01/03/jambda/</link>
      <guid>http://ddongeee.github.io/2022/01/03/jambda/</guid>
      <pubDate>Mon, 03 Jan 2022 02:27:22 GMT</pubDate>
      <description>
      
        
        
          &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;목적&quot;&gt;&lt;a href=&quot;#목적&quot; class=&quot;headerlink&quot; title=&quot;목적&quot;&gt;&lt;/a&gt;목적&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;가장 빠르게 반복적으로 람다를 개발하고 클라우드 환경에서 실행할수 있는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<html><head></head><body><h1 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h1><ul><li>가장 빠르게 반복적으로 람다를 개발하고 클라우드 환경에서 실행할수 있는 sandbox를 만들고 싶다.</li><li>개발 언어에 대한 허들을 최대한 낮추기 위해 언어는 자바로 하고 싶다.</li><li>의존성관리는 그래들을 사용하여, 쉽게 관리하고 싶다.</li></ul><h1 id="결과물"><a href="#결과물" class="headerlink" title="결과물"></a>결과물</h1><ul><li>Github : <a href="https://github.com/ddongEee/jambda" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/ddongEee/jambda</a></li><li>zip 파일로 동작하는 java11 runtime의 lambda</li><li>1번의 명령어(command)로 build & deploy to lambda 가능한 개발환경</li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><h3 id="개인적으로-생각하는-장점"><a href="#개인적으로-생각하는-장점" class="headerlink" title="개인적으로 생각하는 장점"></a>개인적으로 생각하는 장점</h3><ul><li>웹서비스 프로토타입에 대해서 빠르게 개발 및 배포 & 검증 가능하다.</li><li>Lambda 와 integration 되는 서비스를 빠르게 검증하는 용도로 적합하다.</li><li>당연히 규모가 있고 실제 서비스를 제공하기 위한 프로젝트로는 적합하지 않다.</li></ul><h3 id="람다를-자바로-개발하는것에-대한-의미"><a href="#람다를-자바로-개발하는것에-대한-의미" class="headerlink" title="람다를 자바로 개발하는것에 대한 의미"></a>람다를 자바로 개발하는것에 대한 의미</h3><ul><li>익숙함에 따른 생산성 : (자바를 주 언어로 사용한다면) 언어가 아닌 기술과 활용에 집중 가능해짐. 쉬운 시작.</li><li>마이그레이션 : container base의 spring application 으로 migration 시에 language 변경에 대한 추가 리소스 소비 없음</li></ul></body></html>]]></content:encoded>
      
      <comments>http://ddongeee.github.io/2022/01/03/jambda/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Enhanced factory pattern with spring framework</title>
      <link>http://ddongeee.github.io/2019/06/06/spring-design-pattern-first/</link>
      <guid>http://ddongeee.github.io/2019/06/06/spring-design-pattern-first/</guid>
      <pubDate>Wed, 05 Jun 2019 20:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;목표&quot;&gt;&lt;a href=&quot;#목표&quot; class=&quot;headerlink&quot; title=&quot;목표&quot;&gt;&lt;/a&gt;목표&lt;/h1&gt;&lt;p&gt;스프링 프레임워크 프로젝트에서 Bean 생성 혹은 선택을 Factory patte
        
      
      </description>
      
      
      <content:encoded><![CDATA[<html><head></head><body><h1 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h1><p>스프링 프레임워크 프로젝트에서 Bean 생성 혹은 선택을 Factory pattern으로 구현한 설계를 개선한다!</p><ul><li>OCP 에 좀더 부합하도록 코드 리펙터링을 진행하고 싶다.<ul><li>클래스 안에 If, else 구문 제거 시키고 싶다.</li></ul></li><li>재사용성 및 중복코드 제거 하고 싶다.</li></ul><h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>프로젝트를 진행하면서 특정 type으로 서로다른 구현체(Bean)를 필요하는 경우 Factory pattern 을 사용하여 다형성을 구현하였습니다. 이를 통해 다양한 타입에 따른 Bean 생성혹은 선택 로직을 팩토리 클래스 하나에 응집시켜, 관련 로직 수정시 단순히 팩토리 메소드 안에 있는 코드만 수정함으로써 어느정도 유지보수에 도움을 줄수 있었습니다. 하지만 서로 다른 성격의 type들이 추가되고, 이러한 팩토리 클래스 종류도 다양해지고 많아졌습니다. 일반적으로 해당 팩토리 클래스의 구현은 if(type.equals(“A”)) else if .. 와 같은식으로 구현되고 있기 때문에 동일 팩토리 클래스에 새로운 type 을 추가하고 싶을경우 해당 팩토리 클래스의 수정이 불가피 했습니다. 결국 OCP에 부합하지 않는 코드가 계속적으로  만들어 지고 있는중 입니다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMakerFactoryLegacy</span> </span>{</span><br><span class="line"><span class="hljs-comment">//    @Autowired private AmericanoMakerLegacy americanoMakerLegacy;</span></span><br><span class="line"><span class="hljs-comment">//    @Autowired private CappuccinoMakerLegacy cappuccinoMakerLegacy;</span></span><br><span class="line"><span class="hljs-comment">//    @Autowired private EspressoMakerLegacy espressoMakerLegacy;</span></span><br><span class="line">    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CoffeeMakerLegacy americanoMakerLegacy;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CoffeeMakerLegacy cappuccinoMakerLegacy;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CoffeeMakerLegacy espressoMakerLegacy;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CoffeeMakerLegacy <span class="hljs-title">select</span><span class="hljs-params">(CoffeeName coffeeName)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (CoffeeName.Americano == coffeeName) {</span><br><span class="line">            <span class="hljs-keyword">return</span> americanoMakerLegacy;</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CoffeeName.Cappuccino == coffeeName) {</span><br><span class="line">            <span class="hljs-keyword">return</span> cappuccinoMakerLegacy;</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CoffeeName.Espresso == coffeeName) {</span><br><span class="line">            <span class="hljs-keyword">return</span> espressoMakerLegacy;</span><br><span class="line">        } <span class="hljs-keyword">else</span> {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Invalid CoffeeName : "</span> + coffeeName.name());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeMakerLegacy</span> </span>{</span><br><span class="line">    <span class="hljs-function">Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanoMakerLegacy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeMakerLegacy</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Americano();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h1><p>크게 2가지 Skill 을 통해 OCP 에 부합하는 Factory pattern을 구현해 보고자 합니다.</p><ul><li>Spring framework 의 DI </li><li>자료구조중에 Map </li></ul><p>그밖에 다양한 기본기술이 사용되지만, 핵심이 되는 기술은 위와 같습니다.</p><p>그럼 이러한 2가지 기술을 통해, 보다 OCP에 부합되는 소프트웨어를 만들어 봅시다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMakerFactoryList</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> List<CoffeeMakerV1> coffeeMakers;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * getChannel() 호출시, 매번 n(bean 개수)번씩 loop 순회 필요</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CoffeeMakerV1 <span class="hljs-title">select</span><span class="hljs-params">(CoffeeName coffeeName)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> coffeeMakers.stream()</span><br><span class="line">                .filter(c -> c.key() == coffeeName)</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .get(<span class="hljs-number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>List<bean>  autowired 를 통한 첫번째 방법 입니다. select() 호출시, 매번 n번의 Bean 탐색이 필요합니다. </bean></p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMakerFactoryMap</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map<CoffeeName, CoffeeMakerV1> coffeeMakerMap = <span class="hljs-keyword">new</span> HashMap<>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Spring beans 초기화시에 호출</span></span><br><span class="line"><span class="hljs-comment">     **/</span></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List<CoffeeMakerV1> coffeeMakers)</span> </span>{</span><br><span class="line">        coffeeMakers.forEach(c -> coffeeMakerMap.put(c.key(), c));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CoffeeMakerV1 <span class="hljs-title">select</span><span class="hljs-params">(CoffeeName coffeeName)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> coffeeMakerMap.get(coffeeName);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeMakerV1</span> </span>{</span><br><span class="line">    <span class="hljs-function">CoffeeName <span class="hljs-title">key</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function">Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanoMakerV1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeMakerV1</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CoffeeName <span class="hljs-title">key</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> CoffeeName.Americano;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Americano();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Map<Key, Bean> autowired 를 통한 두번째 방법 입니다. </p><p>위와 같이 만들경우, 새로운 구현체(Bean)가 추가되더라도, 기존의 Factory 클래스의 코드 변경이 없습니다. 스프링 환경의 초기화 시점에 해당 Interface(CoffeeMakerV1) 를 구현하고 있는 bean들은 Autowired 됩니다. 결론적으로 OCP를 충족시켜 줄수 있습니다. 또한 프로젝트에 다양하게 존재한 type별 구현체 if else 구문이 모두 제거 되어 코드 복잡도를 좀더 낮출수 있게 되었습니다. 그렇지만 아직 한가지 아쉬운 부분은 이러한 코드 또한, 다양한 팩토리 메소드 마다 중복 존재한다는 부분입니다. 중복제거 및 재사용 관점에서 알아보겠습니다.</p><h1 id="중복-제거-및-재사용-관점"><a href="#중복-제거-및-재사용-관점" class="headerlink" title="중복 제거 및 재사용 관점"></a>중복 제거 및 재사용 관점</h1><p>위의 아키텍쳐에서 pattern 이 존재하는것을 확인할수있습니다. 이를 하나로 통합하여, 추후에 적용해야하는 다양한 팩토리 클래스에 대해서 일괄 적용한다면, 중복코드 제거 및 재사용성을 높일수 있습니다.  이를 위해 추가적으로 2가지 컨셉을 적용해 보겠습니다.</p><ul><li>디자인 패턴 중 Template pattern</li><li>Spring framework 4.0 에서부터 제공하는 Autowiring of Generic Types</li></ul><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Supported from Spring 4.0 and later</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanSelector</span><<span class="hljs-title">K</span>, <span class="hljs-title">V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Key</span><<span class="hljs-title">K</span>>> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map<K, V> beanMap = <span class="hljs-keyword">new</span> HashMap<>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List<V> beans)</span> </span>{</span><br><span class="line">        beans.forEach(bean -> beanMap.put(bean.key(), bean));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">select</span><span class="hljs-params">(K type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> beanMap.get(type);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Key</span><<span class="hljs-title">K</span>> </span>{</span><br><span class="line">    <span class="hljs-function">K <span class="hljs-title">key</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Key</span><<span class="hljs-title">CoffeeName</span>> </span>{</span><br><span class="line">    <span class="hljs-function">Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMakerBeanSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanSelector</span><<span class="hljs-title">CoffeeName</span>, <span class="hljs-title">CoffeeMaker</span>> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 아래와 같이 CoffeeMaker 구현체인 AmericanoMaker 만 추가함으로써 확장 가능</span></span><br><span class="line"><span class="hljs-comment"> */</span> </span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanoMaker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeMaker</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CoffeeName <span class="hljs-title">key</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> CoffeeName.Americano;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">make</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Americano();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Barista</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> AbstractBeanSelector<CoffeeName, CoffeeMaker> coffeeMakerBeanSelector;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">make</span><span class="hljs-params">(CoffeeName coffeeName)</span> </span>{</span><br><span class="line">        CoffeeMakerV2 coffeeMaker = coffeeMakerBeanSelector.select(coffeeName)</span><br><span class="line">                .orElseThrow(() -> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"못만들어요 : "</span> + coffeeName));</span><br><span class="line">        <span class="hljs-keyword">return</span> coffeeMaker.make();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이제 Barista(최초 caller)는 단순히 AbstractBeanSelector 타입으로만 디펜던시가 존재하며, 스프링에서 coffeeMakerBeanSelector 이름의 구현체 Bean 을 autowiring 시켜 줍니다. 이를 단순히 coffeeMakerBeanSelector.select(coffeeName) 메소드를 통해 Bean을 가지고 올수 있습니다. 이를 위해 기존 클래스를 제외하고 추가 되어야 하는 클래스는 아래와 같이 CoffeeMakerBeanSelector 밖에 없습니다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMakerBeanSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanSelector</span><<span class="hljs-title">CoffeeName</span>, <span class="hljs-title">CoffeeMaker</span>> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이제는 중복 코드가 존재 하지 않습니다. 재사용도 무척 편리합니다.</p><h1 id="딥다이브-깊게생각해보기"><a href="#딥다이브-깊게생각해보기" class="headerlink" title="딥다이브:깊게생각해보기"></a>딥다이브:깊게생각해보기</h1><p>최종적으로 도출된 재사용성이 높은 클래스에는 혹시 이슈가 있을까요? 아니면 추가적으로 필요한 비지니스가 생길수 있을까요? 휴먼에러가 될수도 있고, 의도하였거나 하지 못한 부분이 생겨날수도 있는 부분이 있습니다. 사용하는 자료구조가 Map 이라는것에 이슈가 생길수도 있습니다. 예를들어, 비지니스에 변경및 추가가 생겨서 새로운 CoffeeMaker 구현체가 추가된다고 가정해 봅시다. 그러한 CoffeeMaker의 구현체 Key가 이미 존재하는 구현체의 Key와 겹친다면? 둘중 하나는 CoffeeMaker구현체는 Map의 Value에서 사라져 버리겠죠. 이를 개발자에게 인지시켜주거나 새로운 로직 추가 및 분기가 필요해 보입니다.</p><p>만일 Bean(ex. CoffeeMaker구현체) 마다 유니크한 Key를 가지는것이 원칙일때, 개발과정에서 동일 키를 가진 Bean이 추가됬을 경우, 서비스가 deployed 되기 전에(Spring beans initialize 시점에) 개발자에게 에러 상황을 알려줘야 합니다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Supported from Spring 4.0 and later</span></span><br><span class="line"><span class="hljs-comment"> * Bean 이 Single Key 를 가지고 있고, key 값이 Unique 한 경우.</span></span><br><span class="line"><span class="hljs-comment"> * K:V = 1:1</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractUniqueBeanSelector</span><<span class="hljs-title">K</span>, <span class="hljs-title">V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleKey</span><<span class="hljs-title">K</span>>> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map<K, V> beanMap = <span class="hljs-keyword">new</span> HashMap<>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List<V> beans)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (beans.isEmpty()) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Bean is not exist : "</span> + getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (V bean : beans) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (beanMap.get(bean.key()) != <span class="hljs-keyword">null</span>) {</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Bean's key is not unique : "</span> + bean.key());</span><br><span class="line">            }</span><br><span class="line">            beanMap.put(bean.key(), bean);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional<V> <span class="hljs-title">select</span><span class="hljs-params">(K type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> Optional.ofNullable(beanMap.get(type));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SingleKey</span><<span class="hljs-title">K</span>> </span>{</span><br><span class="line">    <span class="hljs-function">K <span class="hljs-title">key</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>그러나 만약 하나의 key에 2개 이상의 Bean이 존재할수 있다면, 이를 시스템적으로 지원해 주도록 해야합니다. </p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * !Supported from Spring 4.0 and later</span></span><br><span class="line"><span class="hljs-comment"> * Bean 이 Single Key 를 가지고 있고, 하나의 Key 값에 여러 Bean 이 존재하는경우</span></span><br><span class="line"><span class="hljs-comment"> * K:V = 1:n 인경우 사용</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractMultipleBeanSelector</span><<span class="hljs-title">K</span>, <span class="hljs-title">V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleKey</span><<span class="hljs-title">K</span>>> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map<K, List<V>> beanMap = <span class="hljs-keyword">new</span> HashMap<>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List<V> beans)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (beans.isEmpty()) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Bean is not exist : "</span> + getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (V bean : beans) {</span><br><span class="line">            beanMap.computeIfAbsent(bean.key(), k -> <span class="hljs-keyword">new</span> ArrayList<>())</span><br><span class="line">                    .add(bean);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List<V> <span class="hljs-title">select</span><span class="hljs-params">(K type)</span> </span>{</span><br><span class="line">        List<V> beans = beanMap.get(type);</span><br><span class="line">        <span class="hljs-keyword">return</span> beans == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ArrayList<>() : beans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>마지막으로 K:V 가 n:n 일경우</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * !Supported from Spring 4.0 and later</span></span><br><span class="line"><span class="hljs-comment"> * Bean 이 Multiple Key 를 가지고 있고, 하나의 Key 값에 여러 Bean 이 존재하는경우</span></span><br><span class="line"><span class="hljs-comment"> * K:V = n:n 인경우 사용</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractMultipleBeanSelectorWithMultipleKey</span><<span class="hljs-title">K</span>, <span class="hljs-title">V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MultipleKey</span><<span class="hljs-title">K</span>>> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map<K, List<V>> beanMap = <span class="hljs-keyword">new</span> HashMap<>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List<V> beans)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (beans.isEmpty()) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Bean is not exist : "</span> + getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (V bean : beans) {</span><br><span class="line">            <span class="hljs-keyword">for</span> (K key : bean.keys()) {</span><br><span class="line">                beanMap.computeIfAbsent(key, k -> <span class="hljs-keyword">new</span> ArrayList<>())</span><br><span class="line">                          .add(bean);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List<V> <span class="hljs-title">select</span><span class="hljs-params">(K type)</span> </span>{</span><br><span class="line">        List<V> beans = beanMap.get(type);</span><br><span class="line">        <span class="hljs-keyword">return</span> beans == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ArrayList<>() : beans;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MultipleKey</span><<span class="hljs-title">K</span>> </span>{</span><br><span class="line">    <span class="hljs-function">List<K> <span class="hljs-title">keys</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p><img src="https://user-images.githubusercontent.com/10233723/59331508-17930080-8d2f-11e9-96e4-7e7850cfc8f6.png" alt="select-bean-class-uml"></p><p>SpringFramework 안에서 OCP 및 재사용성을 높인 Enhanced Abstract Factory Pattern 을 만들어 보았습니다. </p></body></html>]]></content:encoded>
      
      <comments>http://ddongeee.github.io/2019/06/06/spring-design-pattern-first/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
