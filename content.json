{"pages":[{"title":"","text":"naver-site-verification: naver7f8bedb045f6d9075271fccc4ee26fa8.html","link":"/naver7f8bedb045f6d9075271fccc4ee26fa8.html"}],"posts":[{"title":"Enhanced factory pattern with spring framework","text":"목표스프링 프레임워크 프로젝트에서 Bean 생성 혹은 선택을 Factory pattern으로 구현한 설계를 개선한다! OCP 에 좀더 부합하도록 코드 리펙터링을 진행하고 싶다. 클래스 안에 If, else 구문 제거 시키고 싶다. 재사용성 및 중복코드 제거 하고 싶다. 배경프로젝트를 진행하면서 특정 type으로 서로다른 구현체(Bean)를 필요하는 경우 Factory pattern 을 사용하여 다형성을 구현하였습니다. 이를 통해 다양한 타입에 따른 Bean 생성혹은 선택 로직을 팩토리 클래스 하나에 응집시켜, 관련 로직 수정시 단순히 팩토리 메소드 안에 있는 코드만 수정함으로써 어느정도 유지보수에 도움을 줄수 있었습니다. 하지만 서로 다른 성격의 type들이 추가되고, 이러한 팩토리 클래스 종류도 다양해지고 많아졌습니다. 일반적으로 해당 팩토리 클래스의 구현은 if(type.equals(“A”)) else if .. 와 같은식으로 구현되고 있기 때문에 동일 팩토리 클래스에 새로운 type 을 추가하고 싶을경우 해당 팩토리 클래스의 수정이 불가피 했습니다. 결국 OCP에 부합하지 않는 코드가 계속적으로 만들어 지고 있는중 입니다. 123456789101112131415161718192021222324252627282930313233@Componentpublic class CoffeeMakerFactoryLegacy {// @Autowired private AmericanoMakerLegacy americanoMakerLegacy;// @Autowired private CappuccinoMakerLegacy cappuccinoMakerLegacy;// @Autowired private EspressoMakerLegacy espressoMakerLegacy; @Autowired private CoffeeMakerLegacy americanoMakerLegacy; @Autowired private CoffeeMakerLegacy cappuccinoMakerLegacy; @Autowired private CoffeeMakerLegacy espressoMakerLegacy; public CoffeeMakerLegacy select(CoffeeName coffeeName) { if (CoffeeName.Americano == coffeeName) { return americanoMakerLegacy; } else if (CoffeeName.Cappuccino == coffeeName) { return cappuccinoMakerLegacy; } else if (CoffeeName.Espresso == coffeeName) { return espressoMakerLegacy; } else { throw new RuntimeException(\"Invalid CoffeeName : \" + coffeeName.name()); } }}public interface CoffeeMakerLegacy { Coffee make();}@Componentpublic class AmericanoMakerLegacy implements CoffeeMakerLegacy { @Override public Coffee make() { return new Americano(); }} 문제 해결크게 2가지 Skill 을 통해 OCP 에 부합하는 Factory pattern을 구현해 보고자 합니다. Spring framework 의 DI 자료구조중에 Map 그밖에 다양한 기본기술이 사용되지만, 핵심이 되는 기술은 위와 같습니다. 그럼 이러한 2가지 기술을 통해, 보다 OCP에 부합되는 소프트웨어를 만들어 봅시다. 123456789101112131415@Componentpublic class CoffeeMakerFactoryList { @Autowired private List coffeeMakers; /** * getChannel() 호출시, 매번 n(bean 개수)번씩 loop 순회 필요 */ public CoffeeMakerV1 select(CoffeeName coffeeName) { return coffeeMakers.stream() .filter(c -> c.key() == coffeeName) .collect(Collectors.toList()) .get(0); }} List autowired 를 통한 첫번째 방법 입니다. select() 호출시, 매번 n번의 Bean 탐색이 필요합니다. 12345678910111213141516171819202122232425262728293031323334@Componentpublic class CoffeeMakerFactoryMap { private final Map coffeeMakerMap = new HashMap(); /** * Spring beans 초기화시에 호출 **/ @Autowired private void init(List coffeeMakers) { coffeeMakers.forEach(c -> coffeeMakerMap.put(c.key(), c)); } public CoffeeMakerV1 select(CoffeeName coffeeName) { return coffeeMakerMap.get(coffeeName); }}public interface CoffeeMakerV1 { CoffeeName key(); Coffee make();}@Componentpublic class AmericanoMakerV1 implements CoffeeMakerV1 { @Override public CoffeeName key() { return CoffeeName.Americano; } @Override public Coffee make() { return new Americano(); }} Map autowired 를 통한 두번째 방법 입니다. 위와 같이 만들경우, 새로운 구현체(Bean)가 추가되더라도, 기존의 Factory 클래스의 코드 변경이 없습니다. 스프링 환경의 초기화 시점에 해당 Interface(CoffeeMakerV1) 를 구현하고 있는 bean들은 Autowired 됩니다. 결론적으로 OCP를 충족시켜 줄수 있습니다. 또한 프로젝트에 다양하게 존재한 type별 구현체 if else 구문이 모두 제거 되어 코드 복잡도를 좀더 낮출수 있게 되었습니다. 그렇지만 아직 한가지 아쉬운 부분은 이러한 코드 또한, 다양한 팩토리 메소드 마다 중복 존재한다는 부분입니다. 중복제거 및 재사용 관점에서 알아보겠습니다. 중복 제거 및 재사용 관점위의 아키텍쳐에서 pattern 이 존재하는것을 확인할수있습니다. 이를 하나로 통합하여, 추후에 적용해야하는 다양한 팩토리 클래스에 대해서 일괄 적용한다면, 중복코드 제거 및 재사용성을 높일수 있습니다. 이를 위해 추가적으로 2가지 컨셉을 적용해 보겠습니다. 디자인 패턴 중 Template pattern Spring framework 4.0 에서부터 제공하는 Autowiring of Generic Types 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Supported from Spring 4.0 and later */public abstract class AbstractBeanSelector { private final Map beanMap = new HashMap(); @Autowired private void init(List beans) { beans.forEach(bean -> beanMap.put(bean.key(), bean)); } public V select(K type) { return beanMap.get(type); }}public interface Key { K key();}public interface CoffeeMaker extends Key { Coffee make();}@Componentpublic class CoffeeMakerBeanSelector extends AbstractBeanSelector {}/** * 아래와 같이 CoffeeMaker 구현체인 AmericanoMaker 만 추가함으로써 확장 가능 */ @Componentpublic class AmericanoMaker implements CoffeeMaker { @Override public CoffeeName key() { return CoffeeName.Americano; } @Override public Coffee make() { return new Americano(); }}@Componentpublic class Barista { @Autowired private AbstractBeanSelector coffeeMakerBeanSelector; public Coffee make(CoffeeName coffeeName) { CoffeeMakerV2 coffeeMaker = coffeeMakerBeanSelector.select(coffeeName) .orElseThrow(() -> new RuntimeException(\"못만들어요 : \" + coffeeName)); return coffeeMaker.make(); }} 이제 Barista(최초 caller)는 단순히 AbstractBeanSelector 타입으로만 디펜던시가 존재하며, 스프링에서 coffeeMakerBeanSelector 이름의 구현체 Bean 을 autowiring 시켜 줍니다. 이를 단순히 coffeeMakerBeanSelector.select(coffeeName) 메소드를 통해 Bean을 가지고 올수 있습니다. 이를 위해 기존 클래스를 제외하고 추가 되어야 하는 클래스는 아래와 같이 CoffeeMakerBeanSelector 밖에 없습니다. 123@Componentpublic class CoffeeMakerBeanSelector extends AbstractBeanSelector {} 이제는 중복 코드가 존재 하지 않습니다. 재사용도 무척 편리합니다. 딥다이브:깊게생각해보기최종적으로 도출된 재사용성이 높은 클래스에는 혹시 이슈가 있을까요? 아니면 추가적으로 필요한 비지니스가 생길수 있을까요? 휴먼에러가 될수도 있고, 의도하였거나 하지 못한 부분이 생겨날수도 있는 부분이 있습니다. 사용하는 자료구조가 Map 이라는것에 이슈가 생길수도 있습니다. 예를들어, 비지니스에 변경및 추가가 생겨서 새로운 CoffeeMaker 구현체가 추가된다고 가정해 봅시다. 그러한 CoffeeMaker의 구현체 Key가 이미 존재하는 구현체의 Key와 겹친다면? 둘중 하나는 CoffeeMaker구현체는 Map의 Value에서 사라져 버리겠죠. 이를 개발자에게 인지시켜주거나 새로운 로직 추가 및 분기가 필요해 보입니다. 만일 Bean(ex. CoffeeMaker구현체) 마다 유니크한 Key를 가지는것이 원칙일때, 개발과정에서 동일 키를 가진 Bean이 추가됬을 경우, 서비스가 deployed 되기 전에(Spring beans initialize 시점에) 개발자에게 에러 상황을 알려줘야 합니다. 123456789101112131415161718192021222324252627282930/** * Supported from Spring 4.0 and later * Bean 이 Single Key 를 가지고 있고, key 값이 Unique 한 경우. * K:V = 1:1 */public abstract class AbstractUniqueBeanSelector { private final Map beanMap = new HashMap(); @Autowired private void init(List beans) { if (beans.isEmpty()) { throw new RuntimeException(\"Bean is not exist : \" + getClass().getSimpleName()); } for (V bean : beans) { if (beanMap.get(bean.key()) != null) { throw new RuntimeException(\"Bean's key is not unique : \" + bean.key()); } beanMap.put(bean.key(), bean); } } public Optional select(K type) { return Optional.ofNullable(beanMap.get(type)); }}public interface SingleKey { K key();} 그러나 만약 하나의 key에 2개 이상의 Bean이 존재할수 있다면, 이를 시스템적으로 지원해 주도록 해야합니다. 12345678910111213141516171819202122232425/** * !Supported from Spring 4.0 and later * Bean 이 Single Key 를 가지고 있고, 하나의 Key 값에 여러 Bean 이 존재하는경우 * K:V = 1:n 인경우 사용 */public abstract class AbstractMultipleBeanSelector { private final Map beanMap = new HashMap(); @Autowired private void init(List beans) { if (beans.isEmpty()) { throw new RuntimeException(\"Bean is not exist : \" + getClass().getSimpleName()); } for (V bean : beans) { beanMap.computeIfAbsent(bean.key(), k -> new ArrayList()) .add(bean); } } public List select(K type) { List beans = beanMap.get(type); return beans == null ? new ArrayList() : beans; }} 마지막으로 K:V 가 n:n 일경우 12345678910111213141516171819202122232425262728293031/** * !Supported from Spring 4.0 and later * Bean 이 Multiple Key 를 가지고 있고, 하나의 Key 값에 여러 Bean 이 존재하는경우 * K:V = n:n 인경우 사용 */public abstract class AbstractMultipleBeanSelectorWithMultipleKey { private final Map beanMap = new HashMap(); @Autowired private void init(List beans) { if (beans.isEmpty()) { throw new RuntimeException(\"Bean is not exist : \" + getClass().getSimpleName()); } for (V bean : beans) { for (K key : bean.keys()) { beanMap.computeIfAbsent(key, k -> new ArrayList()) .add(bean); } } } public List select(K type) { List beans = beanMap.get(type); return beans == null ? new ArrayList() : beans; }}public interface MultipleKey { List keys();} 정리 SpringFramework 안에서 OCP 및 재사용성을 높인 Enhanced Abstract Factory Pattern 을 만들어 보았습니다.","link":"/2019/06/06/spring-design-pattern-first/"},{"title":"hello world crayon","text":"Tips {terminal}[myenv:config]Open as sublimetext : subl {terminal} 명령어 위치 탐색 : type -a subl {iterm2} cmd + ] This is H1This is H2This is H3This is H4This is H5This is H6####### This is H7","link":"/2021/12/30/hello-world-crayon/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"springframework","slug":"springframework","link":"/tags/springframework/"},{"name":"designpattern","slug":"designpattern","link":"/tags/designpattern/"},{"name":"factory","slug":"factory","link":"/tags/factory/"},{"name":"sample","slug":"sample","link":"/tags/sample/"}],"categories":[]}